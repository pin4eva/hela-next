{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport Note from \"models/Pnote\";\nimport NoteCat from \"models/NoteCat\";\nimport { Question as NoteQuestion, Answer as NoteAnswer } from \"models/Question\";\nimport { authentication } from \"utils/auth\";\nexport default {\n  Query: {\n    getNoteCats: async () => {\n      try {\n        const noteCats = await NoteCat.find();\n        return noteCats;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteCat: async (_, {\n      slug\n    }) => {\n      try {\n        const noteCat = await NoteCat.findOne({\n          slug\n        });\n        const notes = await Note.find({\n          category: noteCat._id\n        });\n\n        const data = _objectSpread(_objectSpread({}, noteCat._doc), {}, {\n          notes\n        }); // console.log(data);\n\n\n        return data;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteQuestions: async () => {\n      try {\n        const questions = await NoteQuestion.find();\n        return questions;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNotes: async () => {\n      try {\n        let notes = await Note.find();\n        notes = notes.map(note => {\n          return _objectSpread(_objectSpread({}, note._doc), {}, {\n            questions: NoteQuestion.find({\n              note_id: note._id\n            })\n          });\n        });\n        return notes;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNote: async (_, {\n      slug\n    }) => {\n      try {\n        const note = await Note.findOne({\n          slug\n        }).populate(\"questions\"); // const questions = await NoteQuestion.find({ topic: note._id });\n\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNotesByCat: async (_, {\n      category\n    }) => {\n      try {\n        let notes = await Note.find({\n          cat_slug: category\n        });\n        notes = notes.map(note => {\n          return _objectSpread(_objectSpread({}, note._doc), {}, {\n            questions: NoteQuestion.find({\n              note_id: note._id\n            })\n          });\n        });\n        return notes;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteQuestionsByNoteId: async (_, {\n      note_id\n    }) => {\n      try {\n        const questions = await NoteQuestion.find({\n          note_id\n        });\n        return questions;\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  },\n  Mutation: {\n    createNote: async (_, args, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const note = await Note.create(_objectSpread({}, args));\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    createNoteCat: async (_, {\n      name\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const notecat = await NoteCat.create({\n          name\n        });\n        return notecat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    createNoteQuestion: async (_, args, {\n      token\n    }) => {\n      await authentication(token);\n      let {\n        note_id\n      } = args;\n      note_id = await Note.findOne({\n        _id: note_id\n      });\n      if (!note_id) throw new Error(\"Invalid note ID\");\n\n      try {\n        const question = await NoteQuestion.create(_objectSpread({}, args));\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNote: async (_, args, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const note = await Note.findOneAndUpdate({\n          _id: args._id\n        }, args, {\n          new: true\n        });\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNoteCat: async (_, {\n      _id,\n      name\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const cat = await NoteCat.findOneAndUpdate({\n          _id\n        }, {\n          $set: {\n            name\n          }\n        }, {\n          new: true\n        });\n        return cat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNoteQuestion: async (_, args, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const question = await NoteQuestion.findByIdAndUpdate(args._id, _objectSpread({}, args), {\n          new: true\n        });\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNote: async (_, {\n      _id\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const note = await Note.findOne({\n          _id\n        });\n        if (!note) throw Error(\"No record found\");\n        await NoteQuestion.deleteMany({\n          topic: note._id\n        });\n        note.remove();\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNoteCat: async (_, {\n      _id\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const cat = await NoteCat.findById(_id);\n        const notes = await Note.find({\n          category: cat._id\n        });\n        if (notes.length >= 1) throw Error(\"There are notes that depends on this category. delete the notes first and try again\");\n        cat.remove();\n        return cat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNoteQuestion: async (_, {\n      _id\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const question = await NoteQuestion.findOne({\n          _id\n        });\n        question.remove();\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/home/peter/Desktop/projects/hela/law-3/src/graphql/resolvers/noteResolvers.js"],"names":["Note","NoteCat","Question","NoteQuestion","Answer","NoteAnswer","authentication","Query","getNoteCats","noteCats","find","error","Error","getNoteCat","_","slug","noteCat","findOne","notes","category","_id","data","_doc","getNoteQuestions","questions","getNotes","map","note","note_id","getNote","populate","getNotesByCat","cat_slug","getNoteQuestionsByNoteId","Mutation","createNote","args","token","create","createNoteCat","name","notecat","createNoteQuestion","question","updateNote","findOneAndUpdate","new","updateNoteCat","cat","$set","updateNoteQuestion","findByIdAndUpdate","deleteNote","deleteMany","topic","remove","deleteNoteCat","findById","length","deleteNoteQuestion"],"mappings":"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","sourcesContent":["import Note from \"models/Pnote\";\nimport NoteCat from \"models/NoteCat\";\nimport {\n  Question as NoteQuestion,\n  Answer as NoteAnswer,\n} from \"models/Question\";\nimport { authentication } from \"utils/auth\";\n\nexport default {\n  Query: {\n    getNoteCats: async () => {\n      try {\n        const noteCats = await NoteCat.find();\n        return noteCats;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteCat: async (_, { slug }) => {\n      try {\n        const noteCat = await NoteCat.findOne({ slug });\n        const notes = await Note.find({ category: noteCat._id });\n        const data = {\n          ...noteCat._doc,\n          notes,\n        };\n        // console.log(data);\n        return data;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteQuestions: async () => {\n      try {\n        const questions = await NoteQuestion.find();\n        return questions;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n\n    getNotes: async () => {\n      try {\n        let notes = await Note.find();\n        notes = notes.map((note) => {\n          return {\n            ...note._doc,\n            questions: NoteQuestion.find({ note_id: note._id }),\n          };\n        });\n\n        return notes;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNote: async (_, { slug }) => {\n      try {\n        const note = await Note.findOne({ slug }).populate(\"questions\");\n        // const questions = await NoteQuestion.find({ topic: note._id });\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n\n    getNotesByCat: async (_, { category }) => {\n      try {\n        let notes = await Note.find({ cat_slug: category });\n        notes = notes.map((note) => {\n          return {\n            ...note._doc,\n            questions: NoteQuestion.find({ note_id: note._id }),\n          };\n        });\n        return notes;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getNoteQuestionsByNoteId: async (_, { note_id }) => {\n      try {\n        const questions = await NoteQuestion.find({ note_id });\n        return questions;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n  },\n  Mutation: {\n    createNote: async (_, args, { token }) => {\n      await authentication(token);\n\n      try {\n        const note = await Note.create({ ...args });\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    createNoteCat: async (_, { name }, { token }) => {\n      await authentication(token);\n      try {\n        const notecat = await NoteCat.create({ name });\n        return notecat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    createNoteQuestion: async (_, args, { token }) => {\n      await authentication(token);\n      let { note_id } = args;\n      note_id = await Note.findOne({ _id: note_id });\n      if (!note_id) throw new Error(\"Invalid note ID\");\n      try {\n        const question = await NoteQuestion.create({ ...args });\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNote: async (_, args, { token }) => {\n      await authentication(token);\n      try {\n        const note = await Note.findOneAndUpdate({ _id: args._id }, args, {\n          new: true,\n        });\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNoteCat: async (_, { _id, name }, { token }) => {\n      await authentication(token);\n      try {\n        const cat = await NoteCat.findOneAndUpdate(\n          { _id },\n          { $set: { name } },\n          { new: true }\n        );\n        return cat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateNoteQuestion: async (_, args, { token }) => {\n      await authentication(token);\n      try {\n        const question = await NoteQuestion.findByIdAndUpdate(\n          args._id,\n          { ...args },\n          { new: true }\n        );\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNote: async (_, { _id }, { token }) => {\n      await authentication(token);\n      try {\n        const note = await Note.findOne({ _id });\n        if (!note) throw Error(\"No record found\");\n        await NoteQuestion.deleteMany({ topic: note._id });\n        note.remove();\n        return note;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNoteCat: async (_, { _id }, { token }) => {\n      await authentication(token);\n      try {\n        const cat = await NoteCat.findById(_id);\n        const notes = await Note.find({ category: cat._id });\n        if (notes.length >= 1)\n          throw Error(\n            \"There are notes that depends on this category. delete the notes first and try again\"\n          );\n        cat.remove();\n        return cat;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteNoteQuestion: async (_, { _id }, { token }) => {\n      await authentication(token);\n      try {\n        const question = await NoteQuestion.findOne({ _id });\n        question.remove();\n        return question;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n  },\n};\n"]},"metadata":{},"sourceType":"module"}