{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport bcrypt from \"bcryptjs\";\nimport crypto from \"crypto\";\nimport jwt from \"jsonwebtoken\";\nimport { nanoid } from \"nanoid\"; // import nodeMailer from \"nodemailer\";\n\nimport config from \"utils/config\";\nimport { authentication } from \"utils/auth\";\nimport { RepComment } from \"models/Report\";\nimport User from \"models/User\";\nimport sgMail from \"@sendgrid/mail\";\nsgMail.setApiKey(process.env.SENDGRID_API_KEY);\nconst BASE_URL = false ? \"https://server.lawathenaeum.com\" : \"http://localhost:8000\";\nconst randId = nanoid(5); // const transport = nodeMailer.createTransport({\n//   host: config.MAIL_HOST,\n//   port: 465,\n//   secure: true,\n//   auth: {\n//     user: config.MAIL_ADDRESS,\n//     pass: config.MAIL_PASS,\n//   },\n// });\n// const transport = nodeMailer.createTransport({\n// \t// host: config.MAIL_HOST,\n// \t// port: 465,\n// \t// secure: true,\n// \tservice: \"gmail\",\n// \tauth: {\n// \t\tuser: config.GMAIL_ADDRESS,\n// \t\tpass: config.MAIL_PASS,\n// \t},\n// });\n\n/**\n * TODO:\n *\n * 1. [*] Forgot password\n * 2. [*] Change password\n * 3. [*] Email confirmation\n * 4. [] User role and permission\n * 5. [] Upload profile picture\n * 6. [] Change email service\n */\n\nexport default {\n  Query: {\n    getUsers: async (_, args, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        const users = await User.find();\n        return users;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getUser: async (_, {\n      _id\n    }, {\n      token\n    }) => {\n      // await authentication(token);\n      try {\n        const user = await User.findOne({\n          _id\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    me: async (_, {\n      token\n    }) => {\n      // if (!token) return null;\n      try {\n        const data = await jwt.verify(token, config.SECRET);\n        const user = await User.findOne({\n          _id: data._id\n        }, {\n          password: 0\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    auth: async (_, args, {\n      token\n    }) => {\n      const user = await authentication(token);\n      if (user) return user;else return null;\n    }\n  },\n  Mutation: {\n    signup: async (_, {\n      input\n    }) => {\n      const {\n        name,\n        email,\n        password,\n        username\n      } = input;\n      if (!email || !name || !password) throw new Error(\"Fill all input\");\n      let user = await User.findOne({\n        email\n      }); // user = await User.findOne({ username });\n\n      if (user) throw new Error(\"User with same email or username already exist\");\n\n      try {\n        const info = {\n          username,\n          email,\n          name,\n          password: await bcrypt.hash(password, 10),\n          token: nanoid(4)\n        };\n        const mailOptions = {\n          from: \"support@lawathenaeum.com\",\n          to: info.email,\n          subject: \"Please confirm your email\",\n          html: `<h2 align=\"center\">Thank you for registering</h2> <p>Please <a href=\"${BASE_URL}/verify/${info.token}\">verify</a> your account to gain access to our platform</p> <p> or</> <p style=\"text-align:center;\"> copy your verification code <b >${info.token}</b></p>`\n        };\n        const data = await sgMail.send(mailOptions);\n\n        if (data) {\n          user = await User.create(info);\n        }\n\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    login: async (_, {\n      email,\n      password\n    }, {\n      res\n    }) => {\n      if (!email || !password) throw new Error(\"Fill the email and password\");\n      let user = await User.findOne({\n        email\n      });\n      if (!user) throw new Error(\"No record found\");\n      let isMatch = await bcrypt.compareSync(password, user.password);\n      if (!isMatch) throw Error(\"Incorrect password\");\n      let payload = {\n        _id: user._id\n      };\n\n      try {\n        const token = await jwt.sign(payload, config.SECRET, {\n          expiresIn: \"1d\"\n        });\n        res.cookie(\"token\", token, {\n          expires: new Date(Date.now() + 8 * 360000),\n          httpOnly: false,\n          secure: false\n        });\n        return {\n          user,\n          token\n        };\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    verify: async (_, {\n      token\n    }) => {\n      let user = await User.findOne({\n        token\n      });\n\n      if (!user) {\n        throw new Error(\"Invalid token\");\n      }\n\n      try {\n        user = await User.findOneAndUpdate({\n          token\n        }, {\n          $set: {\n            token: \"\"\n          }\n        }, {\n          new: true\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    checkEmail: async (_, {\n      email\n    }) => {\n      let user = await User.findOne({\n        email\n      });\n      if (!user) throw new Error(\"Unknown email\");\n\n      try {\n        user = await User.findOneAndUpdate({\n          _id: user._id\n        }, {\n          $set: {\n            token: crypto.randomBytes(64).toString(\"hex\")\n          }\n        }, {\n          new: true\n        });\n        const mailOptions = {\n          from: config.AUTH_USER,\n          to: user.email,\n          subject: \"Password recovery mail\",\n          html: `<div align=\"center\"><h2 align=\"center\">Password Recovery</h2> <p>Please <a href=\"${BASE_URL}/verify?token=${randId}&ref=${user.token}&type=changepass\">follow the link to update your password</> </p></div>`\n        };\n        await transport.sendMail(mailOptions);\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    forgotPassword: async (_, {\n      token,\n      password\n    }) => {\n      let user = await User.findOne({\n        token\n      });\n      if (!user) throw new Error(\"Invalid or expired token\");\n\n      try {\n        user = await User.findOneAndUpdate({\n          token\n        }, {\n          token: \"\",\n          password: bcrypt.hashSync(password, 10)\n        }, {\n          new: true\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    changePassword: async (_, {\n      password,\n      oldPassword\n    }, {\n      token\n    }) => {\n      let user = await authentication(token);\n      user = await User.findOne({\n        _id: user._id\n      });\n      const isMatch = await bcrypt.compareSync(oldPassword, user.password);\n      if (!isMatch) throw Error(\"Incorrect password\");\n\n      try {\n        user = await User.findOneAndUpdate({\n          _id: user._id\n        }, {\n          password: bcrypt.hashSync(password, 10)\n        }, {\n          new: true\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    deleteUser: async (_, {\n      _id\n    }, {\n      token\n    }) => {\n      const user = await authentication(token);\n      if (user.role !== \"admin\") throw Error(\"You are not authorized to delete a user\");\n\n      try {\n        let user = await User.findOne({\n          _id\n        });\n        if (!user) throw new Error(\"No record found\");\n        await RepComment.deleteMany({\n          author: user._id\n        });\n        user.remove();\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateUser: async (_, {\n      input\n    }, {\n      token\n    }) => {\n      await authentication(token);\n\n      try {\n        let user = await User.findOneAndUpdate({\n          _id: input._id\n        }, _objectSpread({}, input), {\n          new: true\n        });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    }\n  }\n};","map":{"version":3,"sources":["/home/peter/Desktop/projects/hela/law-3/src/graphql/resolvers/userResolver.js"],"names":["bcrypt","crypto","jwt","nanoid","config","authentication","RepComment","User","sgMail","setApiKey","process","env","SENDGRID_API_KEY","BASE_URL","randId","Query","getUsers","_","args","token","users","find","error","Error","getUser","_id","user","findOne","me","data","verify","SECRET","password","auth","Mutation","signup","input","name","email","username","info","hash","mailOptions","from","to","subject","html","send","create","login","res","isMatch","compareSync","payload","sign","expiresIn","cookie","expires","Date","now","httpOnly","secure","findOneAndUpdate","$set","new","checkEmail","randomBytes","toString","AUTH_USER","transport","sendMail","forgotPassword","hashSync","changePassword","oldPassword","deleteUser","role","deleteMany","author","remove","updateUser"],"mappings":"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","sourcesContent":["import bcrypt from \"bcryptjs\";\nimport crypto from \"crypto\";\nimport jwt from \"jsonwebtoken\";\nimport { nanoid } from \"nanoid\";\n// import nodeMailer from \"nodemailer\";\nimport config from \"utils/config\";\nimport { authentication } from \"utils/auth\";\nimport { RepComment } from \"models/Report\";\nimport User from \"models/User\";\nimport sgMail from \"@sendgrid/mail\";\nsgMail.setApiKey(process.env.SENDGRID_API_KEY);\n\nconst BASE_URL =\n  process.env.NODE_ENV === \"production\"\n    ? \"https://server.lawathenaeum.com\"\n    : \"http://localhost:8000\";\n\nconst randId = nanoid(5);\n\n// const transport = nodeMailer.createTransport({\n//   host: config.MAIL_HOST,\n//   port: 465,\n//   secure: true,\n//   auth: {\n//     user: config.MAIL_ADDRESS,\n//     pass: config.MAIL_PASS,\n//   },\n// });\n\n// const transport = nodeMailer.createTransport({\n// \t// host: config.MAIL_HOST,\n// \t// port: 465,\n// \t// secure: true,\n// \tservice: \"gmail\",\n// \tauth: {\n// \t\tuser: config.GMAIL_ADDRESS,\n// \t\tpass: config.MAIL_PASS,\n// \t},\n// });\n/**\n * TODO:\n *\n * 1. [*] Forgot password\n * 2. [*] Change password\n * 3. [*] Email confirmation\n * 4. [] User role and permission\n * 5. [] Upload profile picture\n * 6. [] Change email service\n */\n\nexport default {\n  Query: {\n    getUsers: async (_, args, { token }) => {\n      await authentication(token);\n      try {\n        const users = await User.find();\n        return users;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    getUser: async (_, { _id }, { token }) => {\n      // await authentication(token);\n      try {\n        const user = await User.findOne({ _id });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    me: async (_, { token }) => {\n      // if (!token) return null;\n      try {\n        const data = await jwt.verify(token, config.SECRET);\n        const user = await User.findOne({ _id: data._id }, { password: 0 });\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    auth: async (_, args, { token }) => {\n      const user = await authentication(token);\n      if (user) return user;\n      else return null;\n    },\n  },\n  Mutation: {\n    signup: async (_, { input }) => {\n      const { name, email, password, username } = input;\n      if (!email || !name || !password) throw new Error(\"Fill all input\");\n      let user = await User.findOne({ email });\n      // user = await User.findOne({ username });\n      if (user)\n        throw new Error(\"User with same email or username already exist\");\n      try {\n        const info = {\n          username,\n          email,\n          name,\n          password: await bcrypt.hash(password, 10),\n          token: nanoid(4),\n        };\n        const mailOptions = {\n          from: \"support@lawathenaeum.com\",\n          to: info.email,\n          subject: \"Please confirm your email\",\n          html: `<h2 align=\"center\">Thank you for registering</h2> <p>Please <a href=\"${BASE_URL}/verify/${info.token}\">verify</a> your account to gain access to our platform</p> <p> or</> <p style=\"text-align:center;\"> copy your verification code <b >${info.token}</b></p>`,\n        };\n        const data = await sgMail.send(mailOptions);\n        if (data) {\n          user = await User.create(info);\n        }\n\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    login: async (_, { email, password }, { res }) => {\n      if (!email || !password) throw new Error(\"Fill the email and password\");\n      let user = await User.findOne({ email });\n      if (!user) throw new Error(\"No record found\");\n      let isMatch = await bcrypt.compareSync(password, user.password);\n      if (!isMatch) throw Error(\"Incorrect password\");\n      let payload = {\n        _id: user._id,\n      };\n      try {\n        const token = await jwt.sign(payload, config.SECRET, {\n          expiresIn: \"1d\",\n        });\n\n        res.cookie(\"token\", token, {\n          expires: new Date(Date.now() + 8 * 360000),\n          httpOnly: process.env.NODE_ENV === \" production \",\n          secure: process.env.NODE_ENV === \" production \",\n        });\n\n        return { user, token };\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    verify: async (_, { token }) => {\n      let user = await User.findOne({ token });\n      if (!user) {\n        throw new Error(\"Invalid token\");\n      }\n      try {\n        user = await User.findOneAndUpdate(\n          { token },\n          { $set: { token: \"\" } },\n          { new: true }\n        );\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    checkEmail: async (_, { email }) => {\n      let user = await User.findOne({ email });\n      if (!user) throw new Error(\"Unknown email\");\n      try {\n        user = await User.findOneAndUpdate(\n          { _id: user._id },\n          { $set: { token: crypto.randomBytes(64).toString(\"hex\") } },\n          { new: true }\n        );\n        const mailOptions = {\n          from: config.AUTH_USER,\n          to: user.email,\n          subject: \"Password recovery mail\",\n          html: `<div align=\"center\"><h2 align=\"center\">Password Recovery</h2> <p>Please <a href=\"${BASE_URL}/verify?token=${randId}&ref=${user.token}&type=changepass\">follow the link to update your password</> </p></div>`,\n        };\n        await transport.sendMail(mailOptions);\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    forgotPassword: async (_, { token, password }) => {\n      let user = await User.findOne({ token });\n      if (!user) throw new Error(\"Invalid or expired token\");\n      try {\n        user = await User.findOneAndUpdate(\n          { token },\n          {\n            token: \"\",\n            password: bcrypt.hashSync(password, 10),\n          },\n          { new: true }\n        );\n\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    changePassword: async (_, { password, oldPassword }, { token }) => {\n      let user = await authentication(token);\n\n      user = await User.findOne({ _id: user._id });\n\n      const isMatch = await bcrypt.compareSync(oldPassword, user.password);\n      if (!isMatch) throw Error(\"Incorrect password\");\n\n      try {\n        user = await User.findOneAndUpdate(\n          { _id: user._id },\n          {\n            password: bcrypt.hashSync(password, 10),\n          },\n          { new: true }\n        );\n\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n\n    deleteUser: async (_, { _id }, { token }) => {\n      const user = await authentication(token);\n      if (user.role !== \"admin\")\n        throw Error(\"You are not authorized to delete a user\");\n      try {\n        let user = await User.findOne({ _id });\n        if (!user) throw new Error(\"No record found\");\n\n        await RepComment.deleteMany({ author: user._id });\n\n        user.remove();\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n    updateUser: async (_, { input }, { token }) => {\n      await authentication(token);\n      try {\n        let user = await User.findOneAndUpdate(\n          { _id: input._id },\n          {\n            ...input,\n          },\n          {\n            new: true,\n          }\n        );\n        return user;\n      } catch (error) {\n        throw new Error(error);\n      }\n    },\n  },\n};\n"]},"metadata":{},"sourceType":"module"}